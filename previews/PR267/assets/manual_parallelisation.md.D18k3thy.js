import{_ as i,c as s,o as e,ai as l}from"./chunks/framework.C_8PU7Lu.js";const c=JSON.parse('{"title":"Parallelisation","description":"","frontmatter":{},"headers":[],"relativePath":"manual/parallelisation.md","filePath":"manual/parallelisation.md","lastUpdated":null}'),n={name:"manual/parallelisation.md"};function t(h,a,r,p,o,d){return e(),s("div",null,[...a[0]||(a[0]=[l(`<h1 id="parallelisation" tabindex="-1">Parallelisation <a class="header-anchor" href="#parallelisation" aria-label="Permalink to &quot;Parallelisation&quot;">​</a></h1><p><em>UncertaintyQuantification</em> provides several possibilities to parallelise the execution of a model. Which method to use strongly depends on the model and the available hardware. The simplest way to run a model in parallel is by using the <a href="/UncertaintyQuantification.jl/previews/PR267/manual/parallelisation#ParallelModel"><code>ParallelModel</code></a>.</p><h2 id="parallelmodel" tabindex="-1">ParallelModel <a class="header-anchor" href="#parallelmodel" aria-label="Permalink to &quot;ParallelModel&quot;">​</a></h2><p>With the basic <a href="/UncertaintyQuantification.jl/previews/PR267/manual/gettingstarted#Model"><code>Model</code></a> it is up to the user to implement an efficient function which returns the model responses for all samples simultaneously. Commonly, this will involve vectorized operations. For more complex or longer running models, <em>UncertaintyQuantification</em> provides a simple <a href="/UncertaintyQuantification.jl/previews/PR267/manual/parallelisation#ParallelModel"><code>ParallelModel</code></a>. This model relies on the capabilites of the <code>Distributed</code> module, which is part of the standard library shipped with Julia. Without any present <em>workers</em>, the <a href="/UncertaintyQuantification.jl/previews/PR267/manual/parallelisation#ParallelModel"><code>ParallelModel</code></a> will evaluate its function in a loop for each sample. If one or more workers are present, it will automatically distribute the model evaluations. For this to work, <em>UncertaintyQuantification</em> must be loaded with the <code>@everywhere</code> macro in order to be loaded on all workers. In difference to the standard <code>Model</code> each call to the function used in the <code>ParallelModel</code> is passed a <code>DataFrameRow</code> instead of the full <code>DataFrame</code>.</p><p>In the following example, we first load <code>Distributed</code> and add four local workers. A simple model is then evaluated in parallel. Finally, the workers are removed.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Distributed</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addprocs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># add 4 local workers</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># setup of the model and inputs</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@everywhere</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> begin</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UncertaintyQuantification</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RandomVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RandomVariable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ParallelModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> .+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">samples </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([x, y], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m, samples)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmprocs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">workers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># release the local workers</span></span></code></pre></div><p>It is important to note, that the <a href="/UncertaintyQuantification.jl/previews/PR267/manual/parallelisation#ParallelModel"><code>ParallelModel</code></a> requires some overhead to distribute the function calls to the workers. Therefore it performs significantly slower than the standard <a href="/UncertaintyQuantification.jl/previews/PR267/manual/gettingstarted#Model"><code>Model</code></a> with vectorized operations for a simple function as in this example. The method of executing a model in parallel presented above also applies to the <code>ExternalModel</code>.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>For heavier external models the use of parallel compute clusters through the <a href="/UncertaintyQuantification.jl/previews/PR267/api/slurm#UncertaintyQuantification.SlurmInterface"><code>SlurmInterface</code></a> is recommended. See <a href="/UncertaintyQuantification.jl/previews/PR267/examples/hpc#High-Performance-Computing">High Performance Computing</a>.</p></div>`,8)])])}const E=i(n,[["render",t]]);export{c as __pageData,E as default};
