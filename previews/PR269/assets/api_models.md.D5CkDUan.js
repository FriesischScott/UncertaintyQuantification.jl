import{_ as o,C as d,c as r,o as c,ai as l,j as a,G as i,a as s,w as n}from"./chunks/framework._18x9DZc.js";const C=JSON.parse('{"title":"Models","description":"","frontmatter":{},"headers":[],"relativePath":"api/models.md","filePath":"api/models.md","lastUpdated":null}'),p={name:"api/models.md"},h={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""};function m(g,e,b,E,F,T){const t=d("Badge");return c(),r("div",null,[e[20]||(e[20]=l('<h1 id="models" tabindex="-1">Models <a class="header-anchor" href="#models" aria-label="Permalink to &quot;Models&quot;">​</a></h1><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;Index&quot;">​</a></h2><ul><li><a href="#UncertaintyQuantification.Model"><code>UncertaintyQuantification.Model</code></a></li><li><a href="#UncertaintyQuantification.ParallelModel"><code>UncertaintyQuantification.ParallelModel</code></a></li><li><a href="#UncertaintyQuantification.UQModel"><code>UncertaintyQuantification.UQModel</code></a></li><li><a href="#UncertaintyQuantification.evaluate!-Tuple{ParallelModel, DataFrame}"><code>UncertaintyQuantification.evaluate!</code></a></li><li><a href="#UncertaintyQuantification.evaluate!-Tuple{Model, DataFrame}"><code>UncertaintyQuantification.evaluate!</code></a></li></ul><h2 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to &quot;Types&quot;">​</a></h2>',4)),a("details",h,[a("summary",null,[e[0]||(e[0]=a("a",{id:"UncertaintyQuantification.UQModel",href:"#UncertaintyQuantification.UQModel"},[a("span",{class:"jlbinding"},"UncertaintyQuantification.UQModel")],-1)),e[1]||(e[1]=s()),i(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[3]||(e[3]=a("p",null,"Abstract supertype for all model types",-1)),i(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[2]||(e[2]=[a("a",{href:"https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/1268ca8d532de71211b7b12df74530465243ee50/src/UncertaintyQuantification.jl#L35-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",u,[a("summary",null,[e[4]||(e[4]=a("a",{id:"UncertaintyQuantification.Model",href:"#UncertaintyQuantification.Model"},[a("span",{class:"jlbinding"},"UncertaintyQuantification.Model")],-1)),e[5]||(e[5]=s()),i(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[7]||(e[7]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The function <code>f</code> must accept a <code>DataFrame</code> and return the result of the model for each row in the <code>DataFrame</code> as a vector. The <code>name</code> is used to add the output to the <code>DataFrame</code>.</p>',2)),i(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[6]||(e[6]=[a("a",{href:"https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/1268ca8d532de71211b7b12df74530465243ee50/src/models/model.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",k,[a("summary",null,[e[8]||(e[8]=a("a",{id:"UncertaintyQuantification.ParallelModel",href:"#UncertaintyQuantification.ParallelModel"},[a("span",{class:"jlbinding"},"UncertaintyQuantification.ParallelModel")],-1)),e[9]||(e[9]=s()),i(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ParallelModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The <code>ParallelModel</code> does what the <code>Model</code> does with a small difference. The function <code>f</code> is passed a <code>DataFrameRow</code> not the full <code>DataFrame</code>. If workers (through <code>Distributed</code>) are present, the rows are evaluated in parallel.</p>',2)),i(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[10]||(e[10]=[a("a",{href:"https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/1268ca8d532de71211b7b12df74530465243ee50/src/models/model.jl#L12-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[21]||(e[21]=a("h2",{id:"methods",tabindex:"-1"},[s("Methods "),a("a",{class:"header-anchor",href:"#methods","aria-label":'Permalink to "Methods"'},"​")],-1)),a("details",f,[a("summary",null,[e[12]||(e[12]=a("a",{id:"UncertaintyQuantification.evaluate!-Tuple{Model, DataFrame}",href:"#UncertaintyQuantification.evaluate!-Tuple{Model, DataFrame}"},[a("span",{class:"jlbinding"},"UncertaintyQuantification.evaluate!")],-1)),e[13]||(e[13]=s()),i(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calls <code>m.func</code> with <code>df</code> and adds the result to the <code>DataFrame</code> as a column <code>m.name</code></p>',2)),i(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[14]||(e[14]=[a("a",{href:"https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/1268ca8d532de71211b7b12df74530465243ee50/src/models/model.jl#L32-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",y,[a("summary",null,[e[16]||(e[16]=a("a",{id:"UncertaintyQuantification.evaluate!-Tuple{ParallelModel, DataFrame}",href:"#UncertaintyQuantification.evaluate!-Tuple{ParallelModel, DataFrame}"},[a("span",{class:"jlbinding"},"UncertaintyQuantification.evaluate!")],-1)),e[17]||(e[17]=s()),i(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ParallelModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, df</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calls <code>m.func</code> for each row of <code>df</code> and adds the result to the <code>DataFrame</code> as a column <code>m.name</code>. If workers are added through <code>Distributed</code>, the rows will be evaluated in parallel.</p>',2)),i(t,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[18]||(e[18]=[a("a",{href:"https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/1268ca8d532de71211b7b12df74530465243ee50/src/models/model.jl#L42-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const j=o(p,[["render",m]]);export{C as __pageData,j as default};
