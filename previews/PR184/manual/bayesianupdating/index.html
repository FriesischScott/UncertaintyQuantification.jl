<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayesian Updating · UncertaintyQuantification.jl</title><meta name="title" content="Bayesian Updating · UncertaintyQuantification.jl"/><meta property="og:title" content="Bayesian Updating · UncertaintyQuantification.jl"/><meta property="twitter:title" content="Bayesian Updating · UncertaintyQuantification.jl"/><meta name="description" content="Documentation for UncertaintyQuantification.jl."/><meta property="og:description" content="Documentation for UncertaintyQuantification.jl."/><meta property="twitter:description" content="Documentation for UncertaintyQuantification.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">UncertaintyQuantification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../reliability/">Reliability Analysis</a></li><li><a class="tocitem" href="../metamodels/">Metamodelling</a></li><li class="is-active"><a class="tocitem" href>Bayesian Updating</a><ul class="internal"><li><a class="tocitem" href="#Bayes&#39;-Theorem"><span>Bayes&#39; Theorem</span></a></li><li><a class="tocitem" href="#Markov-Chain-Monte-Carlo"><span>Markov Chain Monte Carlo</span></a></li><li><a class="tocitem" href="#Bayesian-calibration-of-computer-simulations"><span>Bayesian calibration of computer simulations</span></a></li></ul></li><li><a class="tocitem" href="../hpc/">High Performance Computing</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/metamodels/">Metamodels</a></li><li><a class="tocitem" href="../../examples/bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../../examples/hpc/">High Performance Computing</a></li></ul></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../../benchmarks/subset/">Subset Simulation</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/inputs/">Inputs</a></li><li><a class="tocitem" href="../../api/parameter/">Parameter</a></li><li><a class="tocitem" href="../../api/randomvariable/">RandomVariable</a></li><li><a class="tocitem" href="../../api/responsesurface/">ResponseSurface</a></li><li><a class="tocitem" href="../../api/polyharmonicspline/">PolyharmonicSpline</a></li><li><a class="tocitem" href="../../api/simulations/">Simulations</a></li><li><a class="tocitem" href="../../api/bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../../api/slurm/">SlurmInterface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Bayesian Updating</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bayesian Updating</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriesischScott/UncertaintyQuantification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/master/docs/src/manual/bayesianupdating.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bayesian-Updating"><a class="docs-heading-anchor" href="#Bayesian-Updating">Bayesian Updating</a><a id="Bayesian-Updating-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Updating" title="Permalink"></a></h1><p>Bayesian updating is a method of statistical inference where Bayes&#39; theorem is used to update the probability distributions of model parameters based on prior beliefs and available data.</p><h2 id="Bayes&#39;-Theorem"><a class="docs-heading-anchor" href="#Bayes&#39;-Theorem">Bayes&#39; Theorem</a><a id="Bayes&#39;-Theorem-1"></a><a class="docs-heading-anchor-permalink" href="#Bayes&#39;-Theorem" title="Permalink"></a></h2><p>Bayes&#39; theorem is defined as</p><p class="math-container">\[P(\theta|Y) = \frac{P(Y|\theta)P(\theta)}{P(Y)},\]</p><p>where <span>$P(\theta)$</span> is the prior distribution, describing prior belief on <span>$\theta$</span>. <span>$P(Y|\theta)$</span> is the likelihood function evaluating how the data Y supports our belief. This is a function of <span>$\theta$</span> not <span>$Y$</span>. <span>$P(\theta|Y)$</span> is called the posterior distribution and expresses an updated belief under data <span>$Y$</span>. The term <span>$P(Y)$</span>, often called the marginal likelihood, or the evidence. It can be calculated as the integral of the likelihood multiplied by the prior distribution over the sample space of <span>$\theta$</span></p><p class="math-container">\[P(Y) = \int{}P(Y|\theta)P(\theta), d\theta{}.\]</p><p>This term serves as a normalizing constant for the posterior probability. However, as it can be difficult or even impractical to calculate it is often disregarded. Instead, only the product of likelihood and prior is used, as it is proportional to the posterior probability</p><p class="math-container">\[P(\theta|Y) \propto P(Y|\theta)P(\theta).\]</p><p>Based on this relationship, the posterior probability can be approximated without calculation of <span>$P(Y)$</span> using a variety of sampling methods. Classic approaches such as rejection sampling can be inefficient, especially for multivariate cases due to high rejection rates. Instead, Metropolis et al., proposed the use of Markov chains to increase efficiency [<a href="../../references/#metropolisEquationStateCalculations1953">7</a>].</p><h2 id="Markov-Chain-Monte-Carlo"><a class="docs-heading-anchor" href="#Markov-Chain-Monte-Carlo">Markov Chain Monte Carlo</a><a id="Markov-Chain-Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Markov-Chain-Monte-Carlo" title="Permalink"></a></h2><p>Markov chains are sequences of variables, where each variable is dependent on the last. In a discrete space <span>$\Omega$</span> the series of random variables <span>$\{X_1,X_2,\ldots,X_t\}$</span> is called a Marko chain if</p><p class="math-container">\[p(X_t=x_t|X_{t-1}=x_{t-1},\ldots,X_1=x_1) = p(X_t=x_t|X_{t-1}=x_{t-1}) .\]</p><p>A Markov chain is called ergodic or irreducible when it is possible to reach each state from every other state with a positive probability. Markov chains that are ergodic and time-homogeneous, i.e. the probability between states doesn&#39;t depend on time, and have a unique stationary distribution such that</p><p class="math-container">\[\pi(y) = \sum_{x\in\Omega}P(y|x)\pi(x).\]</p><p>The goal of Markov chain Monte Carlo (MCMC) sampling methods is to construct a Markov chain, whose stationary distribution is equal to the posterior distribution of Bayes&#39; theorem. This will result in samples generated from the Markov chain being equivalent to random samples of the desired distribution. The very first MCMC algorithm is the Metropolis-Hastings (MH) Algorithm.</p><h3 id="Metropolis-Hastings"><a class="docs-heading-anchor" href="#Metropolis-Hastings">Metropolis Hastings</a><a id="Metropolis-Hastings-1"></a><a class="docs-heading-anchor-permalink" href="#Metropolis-Hastings" title="Permalink"></a></h3><p>The Metropolis-Hastings algorithm, was published in 1970 by W. K. Hastings [<a href="../../references/#hastingsMonteCarloSampling1970">8</a>]. The MH algorithm is a random-walk algorithm that provides a selection criteria for choosing the next sample <span>$(\theta_{i + 1})$</span> in a Markov chain. This is done through a so-called proposal distribution <span>$q(\theta_{i + 1}|\theta_i)$</span> which is well known and relatively easy to sample from. Usually, symmetric proposal distributions centred at <span>$(\theta_i)$</span> are used, for example Normal and Uniform distributions. A candidate sample <span>$\theta^*$</span> is sampled from the proposal distribution and accepted with probability <span>$\alpha$</span></p><p class="math-container">\[\alpha = \min\left[1,\frac{P(\theta^*|Y)}{P(\theta_i|Y)}\cdot{}\frac{q(\theta_i|\theta^*)}{q(\theta^*|\theta_i)}\right].\]</p><p>Substituting the posterior with Bayes&#39; theorem yields</p><p class="math-container">\[\alpha = \min\left[1,\frac{P(Y|\theta^*)\cdot{}P(\theta^*)/P(Y)}{P(Y|\theta_i)\cdot{}P(\theta_i)/P(Y)}\cdot{}\frac{q(\theta_i|\theta^*)}{q(\theta^*|\theta_i)}\right].\]</p><p>Note, how the normalization constant <span>$P(Y)$</span> cancels out. When the proposal is symmetric <span>$q(\theta_i|\theta^*) = q(\theta^*|\theta_i)$</span> the acceptance probability further simplifies to</p><p class="math-container">\[\alpha = \min\left[1,\frac{P(\theta^*|Y)}{P(\theta_i|Y)}\right].\]</p><p>In practice, a random number <span>$r \sim U(0,1)$</span> is sampled, and the candidate sample is accepted if <span>$a \leq r$</span></p><p class="math-container">\[\theta_{i + 1} = \theta^*     \qquad  \text{if} \quad a \leq r,\\
\theta_{i + 1} = \theta_{i}   \qquad  \text{otherwise.} \\\]</p><p>As an example consider a synthetic data sequence <code>Y</code> as the outcome of 100 Bernoulli trials with unknown success probability <code>p</code> (here p=0.8).</p><pre><code class="language-julia hljs"> n = 100
 Y = rand(n) .&lt;= 0.8</code></pre><p>The likelihood function which, similar to a <code>Model</code> must accept a <code>DataFrame</code>, follows a Binomial distribution and returns the likelihood for each row in the <code>DataFrame</code> as a vector. The prior is chosen as a beta distribution with <span>$\alpha=\beta=1$</span> (uniform on <span>$[0, 1]$</span>). It is often beneficial to use the log-likelihood and log-prior for numerical reasons.</p><pre><code class="language-julia hljs">    function loglikelihood(df)
            return [
                sum(logpdf.(Binomial.(n, df_i.p), sum(Y))) for df_i in eachrow(df)
            ]
        end

logprior = df -&gt; logpdf.(Beta(1,1), df.p)</code></pre><p><strong>UncertaintyQuantification.jl</strong> implements a variant of the MH algorithm known as single-component Metropolis-Hastings, where the proposal and acceptance step is performed independently for each dimension. To run the algorithm, we must first define the <code>SingleComponentMetropolisHastings</code> object which requires the <code>UnivariateDistribution</code> as a <code>proposal</code>, a <code>NamedTuple</code> for <code>x0</code> which defines the starting point of the Markov chain, the number of samples and the number of burn-in samples. The burn-in samples are used to start the chain but later discarded.</p><pre><code class="language-julia hljs">    proposal = Normal(0, 0.2)
    x0 = (;p=0.5)
    n_samples= 4000
    burnin = 500

    mh = SingleComponentMetropolisHastings(proposal, x0, n_samples, burnin)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SingleComponentMetropolisHastings(Normal{Float64}(μ=0.0, σ=0.2), (p = 0.5,), 4000, 500, true)</code></pre><p>The final optional argument <code>islog=true</code> can be omitted when passing the log-likelihood and log-prior. When set to <code>false</code>, the algorithm will <code>log</code> for both the likelihood and prior. Finally, the algorithm is executed using the <code>bayesianupdating</code> function. This function returns the samples and the average acceptance rate.</p><pre><code class="language-julia hljs">mh_samples, α   = bayesianupdating(logprior, loglikelihood, mh)</code></pre><p>The following figure shows a histogram of the samples returned by the Metropolis-Hastings algorithm. For comparison, we also plot the analytical posterior distribution obtained using <a href="https://en.wikipedia.org/wiki/Conjugate_prior">conjugate priors</a> [<a href="../../references/#raiffaAppliedStatisticalDecision1961">9</a>].</p><img src="0c20be8a.svg" alt="Example block output"/><p>As a second example we will attempt to sample from a bimodial target distribution in two dimensions. The prior is uniform over <span>$[-2, 2]$</span> in each dimension and the likelihood is a mixture of two Gaussian functions centred at <span>$[0.5, 0.5]$</span> and <span>$[-0.5, -0.5]$</span>.  The standard deviation for both Gaussians are identical and if small enough will effectively disconnect the two functions.</p><pre><code class="language-julia hljs">prior = Uniform(-2, 2)
logprior = df -&gt; logpdf.(prior, df.x) .+ logpdf.(prior, df.y)

N1 = MvNormal([-0.5, -0.5], 0.1)

N2 = MvNormal([0.5, 0.5], 0.1)

loglikelihood =
    df -&gt; log.([0.5 * pdf(N1, collect(x)) + 0.5 * pdf(N2, collect(x)) for x in eachrow(df)])

n = 2000
burnin = 500

x0 = (; x=0.0, y=0.0)

proposal = Normal()

mh = SingleComponentMetropolisHastings(proposal, x0, n, burnin)

mh_samples, α = bayesianupdating(logprior, loglikelihood, mh)

scatter(mh_samples.x, mh_samples.y; lim=[-2, 2], legend = :none)</code></pre><img src="ae800f5f.svg" alt="Example block output"/><p>The scatter plot clearly shows that the MH algorithm has converged to only one of the two peaks of the bimodial target (contour also plotted). In fact, this is a known weakness of the MH algorithm. However, there are a number of alternative MCMC methods that aim to solve this problem. One of these methods, known as Transitional Markov Chain Monte Carlo [<a href="../../references/#chingTransitionalMarkovChain2007">10</a>], will be presented next.</p><h3 id="Transitional-Markov-Chain-Monte-Carlo"><a class="docs-heading-anchor" href="#Transitional-Markov-Chain-Monte-Carlo">Transitional Markov Chain Monte Carlo</a><a id="Transitional-Markov-Chain-Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Transitional-Markov-Chain-Monte-Carlo" title="Permalink"></a></h3><p>The Transitional Markov Chain Monte Carlo (TMCMC) method [<a href="../../references/#chingTransitionalMarkovChain2007">10</a>] is an extension of the MH algorithm where instead of directly sampling a complex posterior distribution, samples are obtained from a series of simpler <strong>transitional</strong> distributions. The samples are obtained from independent single-step Markov Chains. The transitional distributions are defined as</p><p class="math-container">\[    P^j \propto P(Y|\theta)^{\beta_j} \cdot P(\theta),\]</p><p>where <span>$j \in \{1, \ldots, m \}$</span> is the number of the transition step and <span>$\beta_j$</span> is a tempering parameter with <span>$\beta_1 &lt; \cdots, \beta_m =1$</span>. This enables a slow transition from the prior to the posterior distribution. An important part of the TMCMC algorithm is that the tempering parameter has to be selected as to ensure the transition is smooth and gradual. The algorithm&#39;s authors suggest choosing the parameter such that a coefficient of variation of 100% is maintained in the likelihood <span>$P(Y\theta_i)^{\beta_j-\beta_{j - 1}}$</span>. At each level <span>$j$</span> the starting points for the independent Markov Chains are randomly samples (with replacement) from the current set of samples using statistical weights</p><p class="math-container">\[w(\theta_i) = \frac{P(Y|\theta_i)^{\beta_j-\beta_{j-1}}}{\sum_{i=1}^N P(Y|\theta_i)^{\beta_j-\beta_{j-1}}}.\]</p><p>The complete TMCMC algorithm can be summarized as</p><ol><li>Set <span>$j=0$</span> and <span>$\beta_j=0$</span>. Sample <span>$\theta_i \sim P(\theta)$</span>.</li><li>Set <span>$j = j+1$</span>.</li><li>Compute the next tempering parameter <span>$\beta_j$</span>.</li><li>Determine the weights <span>$w(\theta_i)$</span>.</li><li>Generate a single-step Markov chain for each <span>$\theta_i$</span>.</li><li>Repeat steps (2) to (5) until (and including) <span>$(\beta_j=1)$</span>.</li></ol><p>Returning to the bimodial example, this time using the TMCMC algorithm. In order to apply a different MCMC algorithm we only need to construct a <code>TransitionalMarkovChainMonteCarlo</code> object and pass it to the <code>bayesianupdating</code> method. The definition of prior and likelihood remains the same. In difference to the <code>SingleComponentMetropolisHastings</code> the log evidence is returned instead of the acceptance rate.</p><pre><code class="language-julia hljs">tmcmc = TransitionalMarkovChainMonteCarlo(RandomVariable.(Uniform(-2,2), [:x, :y]), n, burnin)

tmcmc_samples, S = bayesianupdating(logprior, loglikelihood, tmcmc)

scatter(tmcmc_samples.x, tmcmc_samples.y; lim=[-2, 2], label=&quot;TMCMC&quot;)</code></pre><img src="9c010687.svg" alt="Example block output"/><p>The resulting scatter plot shows how TMCMC is able to sample both peaks of the bimodal target distribution. The standard implementation of TMCMC uses a multivariate Gaussian proposal distribution centred at each <span>$\theta_i$</span> with covariance matrix <span>$\Sigma$</span> estimated from the current likelihood scaled by a factor <span>$\beta^2$</span>. This scaling factor defaults to <span>$0.2$</span> as suggested by the authors, but can optionally be passed to the constructor as a fourth argument. Application of different MCMC Algorithms nested in the TMCMC give rise to variants of the algorithm. For example, it is possible to use the previously introduced <code>SingleComponentMetropolisHastings</code> resulting in <code>SingleComponentTransitionalMarkovChainMonteCarlo</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>SingleComponentTransitionalMarkovChainMonteCarlo</code> is currently not available but planned for implementation.</p></div></div><p>For convenience, the prior can be automatically constructed from the random variables passed to <code>TransitionalMarkovChainMonteCarlo</code>.</p><pre><code class="language-julia hljs">tmcmc = TransitionalMarkovChainMonteCarlo(RandomVariable.(Uniform(-2,2), [:x, :y]), n, burnin)

tmcmc_samples, S = bayesianupdating(loglikelihood, tmcmc)</code></pre><h2 id="Bayesian-calibration-of-computer-simulations"><a class="docs-heading-anchor" href="#Bayesian-calibration-of-computer-simulations">Bayesian calibration of computer simulations</a><a id="Bayesian-calibration-of-computer-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-calibration-of-computer-simulations" title="Permalink"></a></h2><p><em>UncertaintyQuantification.jl</em> allows for complex computer models to be included in the Bayesian updating procedure, if for example one wishes to infer unknown model parameters from experimental data of model outputs. Several models can be evaluated in order to compute the likelihood function, by passing a vector of <a href="@ref"><code>UQModel</code></a>s to the <a href="../../api/bayesianupdating/#UncertaintyQuantification.bayesianupdating"><code>bayesianupdating</code></a> method. These will be executed before the likelihood is evaluated and models outputs will be available in the <code>DataFrame</code> inside the likelihood function. There is no restriction on the type of <a href="@ref"><code>UQModel</code></a> used. For example, it is possible to use an <a href="../gettingstarted/#ExternalModel"><code>ExternalModel</code></a> and call an external solver.</p><p>For a complete example refer to the <a href="../../examples/bayesianupdating/#Inverse-eigenvalue-problem">Inverse eigenvalue problem</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metamodels/">« Metamodelling</a><a class="docs-footer-nextpage" href="../hpc/">High Performance Computing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Monday 26 August 2024 16:33">Monday 26 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
