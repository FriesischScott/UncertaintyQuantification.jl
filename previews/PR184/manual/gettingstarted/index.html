<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · UncertaintyQuantification.jl</title><meta name="title" content="Getting Started · UncertaintyQuantification.jl"/><meta property="og:title" content="Getting Started · UncertaintyQuantification.jl"/><meta property="twitter:title" content="Getting Started · UncertaintyQuantification.jl"/><meta name="description" content="Documentation for UncertaintyQuantification.jl."/><meta property="og:description" content="Documentation for UncertaintyQuantification.jl."/><meta property="twitter:description" content="Documentation for UncertaintyQuantification.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">UncertaintyQuantification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Inputs"><span>Inputs</span></a></li><li><a class="tocitem" href="#Dependencies"><span>Dependencies</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li></ul></li><li><a class="tocitem" href="../reliability/">Reliability Analysis</a></li><li><a class="tocitem" href="../metamodels/">Metamodelling</a></li><li><a class="tocitem" href="../bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../hpc/">High Performance Computing</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/metamodels/">Metamodels</a></li><li><a class="tocitem" href="../../examples/bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../../examples/hpc/">High Performance Computing</a></li></ul></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../../benchmarks/subset/">Subset Simulation</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/inputs/">Inputs</a></li><li><a class="tocitem" href="../../api/parameter/">Parameter</a></li><li><a class="tocitem" href="../../api/randomvariable/">RandomVariable</a></li><li><a class="tocitem" href="../../api/responsesurface/">ResponseSurface</a></li><li><a class="tocitem" href="../../api/polyharmonicspline/">PolyharmonicSpline</a></li><li><a class="tocitem" href="../../api/simulations/">Simulations</a></li><li><a class="tocitem" href="../../api/bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../../api/slurm/">SlurmInterface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriesischScott/UncertaintyQuantification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/master/docs/src/manual/gettingstarted.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h1><p>Here we introduce the basic building blocks of <em>UncertaintyQuantification</em>. This includes the inputs such as <code>Parameter</code> or <code>RandomVariable</code> which will feed into any <code>Model</code> for a variety of different analyses. We will also present more advanced concepts including how to model dependencies between the inputs through copulas.</p><h2 id="Inputs"><a class="docs-heading-anchor" href="#Inputs">Inputs</a><a id="Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Inputs" title="Permalink"></a></h2><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><p>A <code>Parameter</code> is defined as a constant scalar value. In addition to value the constructor also requires a <code>Symbol</code> by which it can later be identified in the <code>Model</code>. A <code>Symbol</code> is a Julia object which is often used as a name or label. <code>Symbol</code>s are defined using the <code>:</code> prefix. Parameters represent constant deterministic values. As an example we define a <code>Parameter</code> representing the gravity of Earth.</p><pre><code class="language-julia hljs">g = Parameter(9.81, :g)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Parameter(9.81, :g)</code></pre><p>Parameters are very handy when constants show up in the <code>Model</code> in multiple spaces. Instead of updating every instance in the <code>Model</code>, we can conveniently update the value by changing a single line.</p><h3 id="Random-Variables"><a class="docs-heading-anchor" href="#Random-Variables">Random Variables</a><a id="Random-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Variables" title="Permalink"></a></h3><p>A <code>RandomVariable</code> is essentially a wrapper around any <code>UnivariateDistribution</code> defined in the <em>Distributions.jl</em> package [<a href="../../references/#distributionsjl2021">1</a>]. Similarly to the <code>Parameter</code>, the second argument to the constructor is a <code>Symbol</code> acting as a unique identifier. For example, a standard gaussian random variable is defined by passing <code>Normal()</code> and <code>:x</code> as arguments.</p><pre><code class="language-julia hljs">x = RandomVariable(Normal(), :x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RandomVariable(Normal{Float64}(μ=0.0, σ=1.0), :x)</code></pre><p>A list of all possible distributions can be generated by executing <code>subtypes(UnivariateDistribution)</code> in the Julia REPL (read-eval-print loop). Note that, <em>Distributions</em> is re-exported from <em>UncertaintyQuantification</em> and no separate <code>using</code> statement is necessary. In addition, the most important methods of the <code>UnivariateDistribution</code> including <code>pdf</code>, <code>cdf</code>, and <code>quantile</code>, are also defined for the <code>RandomVariable</code>.</p><p>Random samples can be drawn from a <code>RandomVariable</code> by calling the <code>sample</code> method passing the random variable and the desired number of samples.</p><pre><code class="language-julia hljs">samples = sample(x, 100) # sample(x, MonteCarlo(100))</code></pre><p>The <code>sample</code> method returns a <code>DataFrame</code> with the samples in a single column. When sampling from a <code>Vector</code> of random variables these invidivual columns are automatically merged into one unified <code>DataFrame</code>. By default, this will use stardard Monte Carlo simulation to obtain the samples. Alternatively, any of the quasi-Monte Carlo methods can be used instead.</p><pre><code class="language-julia hljs">samples = sample(x, SobolSampling(100))
samples = sample(x, LatinHypercubeSampling(100))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: n must be a power of 2, automatically increased to 128
└ @ UncertaintyQuantification ~/work/UncertaintyQuantification.jl/UncertaintyQuantification.jl/src/simulations/montecarlo.jl:16</code></pre><p>Many of the advanced simulations, e.g. line sampling or subset simulation require mappings to (and from) the standard normal space, and these are exposed through the <code>to_standard_normal_space!</code> and <code>to_physical_space!</code> methods respectively. These operate on a <code>DataFrame</code> and as such can be applied to samples directly. The transformation is done in-place, i.e. no new <code>DataFrame</code> is returned. As such, in the following example, the samples end up exactly as they were in the beginning.</p><pre><code class="language-julia hljs">to_standard_normal_space!(x, samples)
to_physical_space!(x, samples)</code></pre><h2 id="Dependencies"><a class="docs-heading-anchor" href="#Dependencies">Dependencies</a><a id="Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies" title="Permalink"></a></h2><p><em>UncertaintyQuantification</em> supports modelling of dependencies through copulas. By using copulas, the modelling of the dependence structure is separated from the modelling of the univariate marginal distributions. The basis for copulas is given by Sklar&#39;s theorem [<a href="../../references/#sklarFonctionsRepartitionDimensions1959">2</a>]. It states that any multivariate distribution <span>$H$</span> in dimensions <span>$d \geq 2$</span> can be separated into its marginal distributions <span>$F_i$</span> and a copula function C $.</p><p class="math-container">\[H(x_1,\ldots,x_2) = C(F_1(x_1),\ldots,F_d(x_d))\]</p><p>For a thorough discussion of copulas, see [<a href="../../references/#joeDependenceModelingCopulas2015">3</a>].</p><p>In line with Sklar&#39;s theorem we build the joint distribution of two dependent random variables by separately defining the marginal distributions.</p><pre><code class="language-julia hljs">x = RandomVariable(Normal(), :x)
y = RandomVariable(Uniform(), :y)
marginals = [x, y]</code></pre><p>Next, we define the copula to model the dependence. <em>UncertaintyQuantification</em> supports Gaussian copulas for multivariate <span>$d \geq 2$</span> dependence. Here, we define a Gaussian copula by passing the correlation matrix and then build the <code>JointDistribution</code> from the copula and the marginals.</p><pre><code class="language-julia hljs">cop = GaussianCopula([1 0.8; 0.8 1])
joint = JointDistribution(marginals, cop)</code></pre><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><p>In this section we present the models included in <em>UncertaintyQuantification</em>. A model, in its most basic form, is a relationship between a set of input variables <span>$x \in \mathbb{R}^{n_x}$</span> and an output <span>$y \in \mathbb{R}$</span>. Currently, most models are assumed to return single-valued outputs. However, as seen later, the <code>ExternalModel</code> is capable of extracting an arbitrary number of outputs from a single run of an external solver.</p><h3 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h3><p>A <code>Model</code> is essentially a native Julia function operating on the previously defined inputs. Building a <code>Model</code> requires two things: a <code>Function</code>, which is internally passed a <code>DataFrame</code> containing the samples and must return a <code>Vector</code> containing the model response for each sample, and a <code>Symbol</code> which is the identifier used to add the model output into the <code>DataFrame</code>.</p><p>Suppose we wanted to define a <code>Model</code> which computes the distance from the origin of two variables <span>$x$</span> and <span>$y$</span> as <span>$z$</span>. We first define the function and then pass it to the <code>Model</code>.</p><pre><code class="language-julia hljs">function z(df::DataFrame)
  return @. sqrt(df.x^2 + df.y^2)
end
m = Model(z, :z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model(Main.z, :z)</code></pre><p>An alternative for a simple model such as this, is to directly pass an anonymous function to the <code>Model</code>.</p><pre><code class="language-julia hljs">m = Model(df -&gt; sqrt.(df.x.^2 .+ df.y.^2), :z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model(Main.var&quot;#1#2&quot;(), :z)</code></pre><p>After defining it, a <code>Model</code> can be evaluated on a set of samples by calling the <code>evaluate!</code> method. This will add the model outcome to the <code>DataFrame</code>. Alternatively, the reponse can be obtained as a vector, by calling the <code>Model</code> as a function.</p><pre><code class="language-julia hljs">samples = sample([x, y], MonteCarlo(1000))
evaluate!(m, samples) # add to the DataFrame
output = m(samples) # return a Vector</code></pre><p>However, most of the time manual evaluation of the <code>Model</code> will not be necessary as it is done internally by whichever analysis is performed.</p><h3 id="ParallelModel"><a class="docs-heading-anchor" href="#ParallelModel">ParallelModel</a><a id="ParallelModel-1"></a><a class="docs-heading-anchor-permalink" href="#ParallelModel" title="Permalink"></a></h3><p>With the basic <code>Model</code> it is up to the user to implement an efficient function which returns the model responses for all samples simultaneously. Commonly, this will involve vectorized operations as presented in the example. For more complex or longer running models, <em>UncertaintyQuantification</em> provides a simple <code>ParallelModel</code>. This model relies on the capabilites of the <code>Distributed</code> module, which is part of the standard library shipped with Julia. Without any present <em>workers</em>, the <code>ParallelModel</code> will evaluate its function in a loop for each sample. If one or more workers are present, it will automatically distribute the model evaluations. For this to work, <em>UncertaintyQuantification</em> must be loaded with the <code>@everywhere</code> macro in order to be loaded on all workers. In the following example, we first load <em>Distributed</em> and add four local workers. A simple model is then evaluated in parallel. Finally, the workers are removed.</p><pre><code class="language-julia hljs">using Distributed
addprocs(4) # add 4 local workers

@everywhere using UncertaintyQuantification

x = RandomVariable(Normal(), :x)
y = RandomVariable(Normal(), :y)

m = ParallelModel(df -&gt; sqrt(df.x^2 .+ df.y^2), :z)

samples = sample([x, y], 1000)
evaluate!(m, samples)

rmprocs(workers()) # release the local workers</code></pre><p>It is important to note, that the <code>ParallelModel</code> requires some overhead to distribute the function calls to the workers. Therefore it performs significantly slower than the standard <code>Model</code> with vectorized operations for a simple function as in this example.</p><p>By using <em>ClusterManagers.jl</em> to add the workers, the <code>ParallelModel</code> can easily be run on an existing compute cluster such as <em>Slurm</em>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For heavier external models or workflows in parallel on compute clusters, using <code>SlurmInterface</code> is recommended. See <a href="../hpc/">High Performance Computing</a>.</p></div></div><h3 id="ExternalModel"><a class="docs-heading-anchor" href="#ExternalModel">ExternalModel</a><a id="ExternalModel-1"></a><a class="docs-heading-anchor-permalink" href="#ExternalModel" title="Permalink"></a></h3><p>The <code>ExternalModel</code> provides interaction with almost any third-party solver. The only requirement is, that the solver uses text-based input and output files in which the values sampled from the random variables can be injected for each individual run. The output quantities are then extracted from the files generated by the solver using one (or more) <code>Extractor</code>(s). This way, the simulation techniques included in this module, can be applied to advanced models in finite element software such as <em>OpenSees</em> or <em>Abaqus</em>.</p><p>The first step in building the <code>ExternalModel</code> is to define the folder where the source files can be found as well as the working directory. Here, we assume that the source file for a simple supported beam model is located in a subdirectory of our current working directory. Similarly, the working directory for the solver is defined. In addition, we define the exact files where values need to be injected, and any extra files required. No values will be injected into the files specified as extra. In this example, no extra files are needed, so the variable is defined as an empty <code>String</code> vector.</p><pre><code class="language-julia hljs">sourcedir = joinpath(pwd(), &quot;demo/models&quot;)
sourcefiles = [&quot;supported-beam.tcl&quot;]
extrafiles = String[]
workdir = joinpath(pwd(), &quot;supported-beam&quot;)</code></pre><p>Next, we must define where to inject values from the random variables and parameters into the input files. For this, we make use of the <em>Mustache.jl</em> and <em>Formatting.jl</em> modules. The values in the source file must be replaced by triple curly bracket expressions of the form <code>{{{ :x }}}</code>,  where <code>:x</code> is the identifier of the <code>RandomVariable</code> or <code>Parameter</code> to be injected. For example, to inject the Young&#39;s modulus and density of an elastic isotropic material in <em>OpenSees</em>, one could write the following.</p><pre><code class="language-tcl hljs">nDMaterial ElasticIsotropic 1 {{{ :E }}} 0.25 {{{ :rho }}}</code></pre><p>This identifies where to inject the values, but not in which format. For this reason, we define a <code>Dict{Symbol, String}</code> which maps the identifiers of the inputs to a Python-style format string. In order to inject our values in scientific notation with eight digits, we use the format string <code>&quot;.8e&quot;</code>. For any not explicitly defined <code>Symbol</code> we can include <code>:*</code> as a fallback.</p><pre><code class="language-julia hljs">formats = Dict(:E =&gt; &quot;.8e&quot;,:rho =&gt; &quot;.8e&quot;, :* =&gt; &quot;.12e&quot;)</code></pre><p>After formatting and injecting the values into the source file, it would look similar to this.</p><pre><code class="language-tcl hljs">nDMaterial ElasticIsotropic 1 9.99813819e+02 0.25 3.03176259e+00</code></pre><p>Now that the values are injected into the source files, the next step is to extract the desired output quantities. This is done using an <code>Extractor</code>. The <code>Extractor</code> is designed similarly to the <code>Model</code> in that it takes a <code>Function</code> and a <code>Symbol</code> as its parameters. However, where a <code>DataFrame</code> is passed to the <code>Model</code>, the working directoy for the currently evaluated sample is passed to the function of the <code>Extractor</code>. The user defined function must then extract the required values from the file and return them. Here, we make use of the <em>DelimitedFiles</em> module to extract the maximum absolute displacement from the output file that <em>OpenSees</em> generated.</p><pre><code class="language-julia hljs">disp = Extractor(base -&gt; begin
  file = joinpath(base, &quot;displacement.out&quot;)
  data = readdlm(file, &#39; &#39;)

  return maximum(abs.(data[:, 2]))
end, :disp)</code></pre><p>An arbitrary number of <code>Extractor</code> functions can be defined in order to extract multiple output values from the solver.</p><p>The final step before building the model is to define the solver. The solver requires the path to the binary, and the input file. Optional command line arguments can be passed to the <code>Solver</code> through the <code>args</code> keyword. If the solver binary is not on the system path, the full path to the executable must be defined. Finally, the <code>ExternalModel</code> is assembled.</p><pre><code class="language-julia hljs">opensees = Solver(
  &quot;OpenSees&quot;,
  &quot;supported-beam.tcl&quot;;
  args = &quot;&quot;
)

ext = ExternalModel(
  sourcedir, sourcefiles, disp, opensees; formats=numberformats, workdir=workdir, extras=extrafiles
)</code></pre><p>A full example of how to run a reliability analysis of a model defined in <em>OpenSees</em> can be found in the demo files.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../reliability/">Reliability Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Tuesday 3 September 2024 08:34">Tuesday 3 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
