<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reliability Analysis · UncertaintyQuantification.jl</title><meta name="title" content="Reliability Analysis · UncertaintyQuantification.jl"/><meta property="og:title" content="Reliability Analysis · UncertaintyQuantification.jl"/><meta property="twitter:title" content="Reliability Analysis · UncertaintyQuantification.jl"/><meta name="description" content="Documentation for UncertaintyQuantification.jl."/><meta property="og:description" content="Documentation for UncertaintyQuantification.jl."/><meta property="twitter:description" content="Documentation for UncertaintyQuantification.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">UncertaintyQuantification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Reliability Analysis</a><ul class="internal"><li><a class="tocitem" href="#Definition-of-the-Input,-Model-and-Performance"><span>Definition of the Input, Model and Performance</span></a></li><li><a class="tocitem" href="#Approximation-Methods"><span>Approximation Methods</span></a></li><li><a class="tocitem" href="#Simulation-Methods"><span>Simulation Methods</span></a></li><li><a class="tocitem" href="#Subset-Simulation"><span>Subset Simulation</span></a></li></ul></li><li><a class="tocitem" href="../metamodels/">Metamodelling</a></li><li><a class="tocitem" href="../bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../hpc/">High Performance Computing</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/metamodels/">Metamodels</a></li><li><a class="tocitem" href="../../examples/bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../../examples/hpc/">High Performance Computing</a></li></ul></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../../benchmarks/subset/">Subset Simulation</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/inputs/">Inputs</a></li><li><a class="tocitem" href="../../api/responsesurface/">ResponseSurface</a></li><li><a class="tocitem" href="../../api/polyharmonicspline/">PolyharmonicSpline</a></li><li><a class="tocitem" href="../../api/simulations/">Simulations</a></li><li><a class="tocitem" href="../../api/bayesianupdating/">Bayesian Updating</a></li><li><a class="tocitem" href="../../api/slurm/">SlurmInterface</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Reliability Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reliability Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriesischScott/UncertaintyQuantification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriesischScott/UncertaintyQuantification.jl/blob/master/docs/src/manual/reliability.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reliability-Analysis"><a class="docs-heading-anchor" href="#Reliability-Analysis">Reliability Analysis</a><a id="Reliability-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Reliability-Analysis" title="Permalink"></a></h1><p>In the context of structural engineering, engineering design, and risk assessment, the term reliability is used to describe the ability of system to perform its intended function under varying conditions over time.</p><p>There, the state of a system is identified by its <em>performance function</em> <span>$g(\boldsymbol{x})$</span> such that:</p><p class="math-container">\[g(\boldsymbol{x}) =
\begin{cases}
    &gt; 0 &amp; \text{safe\ domain}\\
    \leq 0 &amp; \text{failure \ domain}\\
\end{cases}.\]</p><p>Then the <em>probability of failure</em> is defined as the likelihood of the system being in the failed state, given as</p><p class="math-container">\[p_f = \int_{g(\boldsymbol{x}) \leq 0} f_{\boldsymbol{X}}(\boldsymbol{x}) \mathrm{d} \boldsymbol{x}.\]</p><p>Here, <span>$f_{\boldsymbol{X}}(\boldsymbol{x})$</span> denotes the joint probability density function (PDF) of the input <span>$\boldsymbol{X}$</span>.</p><h2 id="Definition-of-the-Input,-Model-and-Performance"><a class="docs-heading-anchor" href="#Definition-of-the-Input,-Model-and-Performance">Definition of the Input, Model and Performance</a><a id="Definition-of-the-Input,-Model-and-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-Input,-Model-and-Performance" title="Permalink"></a></h2><p>The first step of the implementation of a reliability analysis in <code>UncertaintyQuantification.jl</code> is the definition of the probabilistic input and the model which is shown exemplarily.</p><p>Here we use a modification of the first example presented in [<a href="../../references/#papaioannouCombination2021">9</a>] which uses a quadratic performance function and a probabilistic input containing of two standard normal random variables <span>$\boldsymbol{X} = [X_1, X_2]$</span> with <span>$X_i \sim \mathcal{N}(0,1)$</span>. The model is given as</p><p class="math-container">\[y(\boldsymbol{X}) = 0.1(X_1 - X_2)^2 - \frac{1}{\sqrt{2}} (X_1 + X_2).\]</p><p>Then, the performance function is defined as</p><p class="math-container">\[g(\boldsymbol{X}) = y(\boldsymbol{X}) + 4.\]</p><p>The probabilistic input is implemented as</p><pre><code class="language-julia hljs">x = RandomVariable.(Normal(), [:x1, :x2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{RandomVariable}:
 RandomVariable(Normal{Float64}(μ=0.0, σ=1.0), :x1)
 RandomVariable(Normal{Float64}(μ=0.0, σ=1.0), :x2)</code></pre><p>Next we define the model for the response <span>$y(\boldsymbol{X})$</span> as</p><pre><code class="language-julia hljs">y = Model(df -&gt; 0.1*(df.x1 - df.x2).^2 - 1/sqrt(2) * (df.x1 + df.x2), :y)</code></pre><p>where the first input is the function <span>$y$</span> (which must accept a <code>DataFrame</code>) and the second argument is the <code>Symbol</code> for the output variable. With the help of the model, we can define the performance function <span>$g$</span> which again takes a <code>DataFrame</code> as an input:</p><pre><code class="language-julia hljs">g(df) = df.y .+ 4</code></pre><h2 id="Approximation-Methods"><a class="docs-heading-anchor" href="#Approximation-Methods">Approximation Methods</a><a id="Approximation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-Methods" title="Permalink"></a></h2><h3 id="First-Order-Reliability-Method"><a class="docs-heading-anchor" href="#First-Order-Reliability-Method">First Order Reliability Method</a><a id="First-Order-Reliability-Method-1"></a><a class="docs-heading-anchor-permalink" href="#First-Order-Reliability-Method" title="Permalink"></a></h3><p>The First Order Reliability Method (FORM) [<a href="../../references/#rackwitzStructuralReliability1978">10</a>] estimates the failure probability by finding a linear approximation of the performance function at the so-called <em>design point</em> <span>$\boldsymbol{U}^*$</span>. The design point represents the point on the surface of the performance function <span>$g(\boldsymbol{X}) = 0$</span> that is closest to the origin in the standard normal space.</p><p>That distance from the design point to the origin is referred to as the <em>reliability index</em> given as <span>$\beta^* = ||\boldsymbol{U}^*||$</span>. Due to the transformation to the standard normal space, the probability of failure is simply given as</p><p class="math-container">\[\hat{p}_{f, \mathrm{FORM}} = \Phi(-\beta^*)\]</p><p>where <span>$\Phi$</span> denotes the standard normal CDF.</p><p>In addition to the <span>$\beta^*$</span>, the location of the design point is specified by the <em>important direction</em> defined as:</p><p class="math-container">\[\boldsymbol{\alpha}^* = \frac{\boldsymbol{U}^*}{||\boldsymbol{U}^*||}.\]</p><p>In <code>UncertaintyQuantification.jl</code> a FORM analysis can be performed calling <code>probability_of_failure(model, performance, input, simulation)</code> where <code>FORM()</code> is passed as the simulation method:</p><pre><code class="language-julia hljs">pf_form, β, dp = probability_of_failure(y, g, x, FORM())

println(&quot;Probability of failure: $pf_form&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 3.1671241833194436e-5</code></pre><h2 id="Simulation-Methods"><a class="docs-heading-anchor" href="#Simulation-Methods">Simulation Methods</a><a id="Simulation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Methods" title="Permalink"></a></h2><h3 id="Monte-Carlo-Simulation"><a class="docs-heading-anchor" href="#Monte-Carlo-Simulation">Monte Carlo Simulation</a><a id="Monte-Carlo-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-Simulation" title="Permalink"></a></h3><p>Monte Carlo Simulation (MCS) offers an approximation of the failure probability using stochastic simulation.</p><p>It utilizes an indicator function of the failure domain</p><p class="math-container">\[\mathbb{I}[g(\boldsymbol{x})] =
\begin{cases}
    0 &amp; \text{when} \ g(\boldsymbol{x}) &gt; 0\\
    1 &amp; \text{when} \ g(\boldsymbol{x}) \leq 0\\
\end{cases}.\]</p><p>This allows for the failure probability to be interpreted as the expected value of the indicator function</p><p class="math-container">\[p_f = \int_{\boldsymbol{X}} \mathbb{I}[g(\boldsymbol{x})]\ f_{\boldsymbol{X}}(\boldsymbol{x}) \mathrm{d} \boldsymbol{x} = \mathbb{E}\big[\mathbb{I}[g(\boldsymbol{x})]\big].\]</p><p>The Monte Carlo estimate of the failure probability is given as</p><p class="math-container">\[p_f \approx \hat{p}_f = \frac{1}{N} \sum_{i=1}^N \mathbb{I}[g(\boldsymbol{x}_i)]\]</p><p>where <span>$\{\boldsymbol{x}_i\}_{i=1}^N$</span> represents a set of <span>$N$</span> samples drawn from the input PDF <span>$f_{\boldsymbol{X}}(\boldsymbol{x})$</span>. The variance of the estimator is given as</p><p class="math-container">\[\operatorname{Var}[\hat{p}_f] = \frac{\hat{p}_f (1-\hat{p}_f)}{N}.\]</p><p>In <code>UncertaintyQuantification.jl</code> we can perform a Monte Carlo Simulation by defining the analysis as <code>MonteCarlo(n)</code>  where <code>n</code> is the number of samples:</p><pre><code class="language-julia hljs">mc = MonteCarlo(10^7)</code></pre><p>Then the reliability analysis is performed by calling <code>probability_of_failure(model, performance, input, simulation)</code>.</p><pre><code class="language-julia hljs">pf_mc, std_mc, samples = probability_of_failure(y, g, x, mc)

println(&quot;Probability of failure: $pf_mc&quot;)
println(&quot;Coefficient of variation: $(std_mc/pf_mc)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 2.03e-5
Coefficient of variation: 0.07018552824040179</code></pre><h3 id="Importance-Sampling"><a class="docs-heading-anchor" href="#Importance-Sampling">Importance Sampling</a><a id="Importance-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Importance-Sampling" title="Permalink"></a></h3><p>Based on the standard MCS method, a class of advanced method exist that have to goal to accelerate the estimation of the failure probability by requiring fewer model calls.</p><p>Importance Sampling [<a href="../../references/#melchersImportanceSampling1989">11</a>] introduces a second density that is <em>biased</em> in a way that it generates more samples in the failure domain. Typically such a density is constructed around the design point obtained in a preceding FORM analysis.</p><p>In order to perform a reliability analysis using Importance Sampling, we again have to specify the number of samples and then can <code>probability_of_failure()</code>.</p><pre><code class="language-julia hljs">is = ImportanceSampling(1000)
pf_is, std_is, samples = probability_of_failure(y, g, x, is)

println(&quot;Probability of failure: $pf_is&quot;)
println(&quot;Coefficient of variation: $(std_is/pf_is)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 2.0208863851917025e-5
Coefficient of variation: 0.048397814394442344</code></pre><h3 id="Line-Sampling"><a class="docs-heading-anchor" href="#Line-Sampling">Line Sampling</a><a id="Line-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Sampling" title="Permalink"></a></h3><p>Another advanced Monte Carlo method for reliability analysis is Line Sampling [<a href="../../references/#koutsourelakisReliability2004">12</a>]. Its main idea is to use parallel lines for sampling rather than points.</p><p>Therefore first the problem is transformed into the standard normal space to make use of the invariance of rotation. The important direction <span>$\boldsymbol{\alpha}$</span> is determined, e.g., using FORM or the gradient at the origin. Then, samples are generated and projected onto the hyperplane orthogonal to <span>$\boldsymbol{\alpha}$</span>. From each point on the hyperplane, a line is drawn parallel to <span>$\boldsymbol{\alpha}$</span> and its intersection with the performance function is determined using root finding based on a spline interpolation scheme, giving the set of distances <span>$\{\beta^{(i)}\}_{i=1}^N$</span> from the hyperplane to the intersection with the performance function. Due to working in the standard normal space, the <em>failure probability along each line</em> is given as</p><p class="math-container">\[p_{f, \mathrm{line}}^{(i)} = \Phi(-\beta^{(i)})\]</p><p>Finally, the probability of failure is obtained as the mean of the failure probabilities along the lines</p><p class="math-container">\[\hat{p}_{f,\mathrm{LS}} = \frac{1}{N} \sum_{i=1}^N p_{f, \mathrm{line}}^{(i)}.\]</p><p>The variance of <span>$\hat{p}_{f,\mathrm{LS}}$</span> is given by the variance of the line failure probabilities:</p><p class="math-container">\[\operatorname{Var}[\hat{p}_{f,\mathrm{LS}}] = \frac{1}{N(N-1)} \sum_{i=1}^N \Big(p_{f, \mathrm{line}}^{(i)} - \hat{p}_{f,\mathrm{LS}}\Big)^2.\]</p><p>Similar to standard MCS, we have to pass <span>$N$</span> to the Line Sampling method. However, here we pass the number of lines. Optionally, we can pass a vector of the points along each line that are used to evaluate the performance function and a predetermined direction <span>$\boldsymbol{\alpha}$</span>:</p><pre><code class="language-julia hljs">ls = LineSampling(100, collect(0.5:0.5:10))
pf_ls, std_ls, samples = probability_of_failure([y], g, x, ls)

println(&quot;Probability of failure: $pf_ls&quot;)
println(&quot;Coefficient of variation: $(std_ls/pf_ls)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 1.7559668525290613e-5
Coefficient of variation: 0.058717834809608196</code></pre><h3 id="Advanced-Line-Sampling"><a class="docs-heading-anchor" href="#Advanced-Line-Sampling">Advanced Line Sampling</a><a id="Advanced-Line-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Line-Sampling" title="Permalink"></a></h3><p>Advanced Line Sampling [<a href="../../references/#deangelisAdvances2015">13</a>] is a further enhancement of the standard line sampling methods due to two main features:</p><ol><li>The important direction <span>$\boldsymbol{\alpha}$</span> is adapted once a more probable point is found</li><li>The lines are processed sorted by proximity of the points on the hyperplane.</li></ol><p>Especially the second point enables the use of an iterative root finder using Newton&#39;s method.</p><p>The definition of the <code>AdvancedLineSampling</code> simulation method is similar to that of regular Line Sampling. The number of lines has to be given to the constructor and we can optionally give the number of points along the line which is only used to find the starting point of the iterative root search.</p><pre><code class="language-julia hljs">als = AdvancedLineSampling(100, collect(0.5:0.5:10))
pf_als, std_als, samples = probability_of_failure([y], g, x, als)

println(&quot;Probability of failure: $pf_als&quot;)
println(&quot;Coefficient of variation: $(std_als/pf_als)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 1.8137034396872834e-5
Coefficient of variation: 0.06149133639983706</code></pre><p>For <code>AdvancedLineSampling</code>, we can also define the (initial) direction and options of the iterative root finding, i.e., the <code>tolerance</code>, <code>stepsize</code> of the gradient and <code>maxiterations</code>.</p><div class="admonition is-info"><header class="admonition-header">Parallelism</header><div class="admonition-body"><p>We note that Advanced Line Sampling is a serial algorithm, although much fewer samples (order of magnitude) are required. If a large amount of parallel compute is available, standard Line Sampling may be more attractive, which is &quot;embarrassingly&quot; parallel like Monte Carlo.</p></div></div><h2 id="Subset-Simulation"><a class="docs-heading-anchor" href="#Subset-Simulation">Subset Simulation</a><a id="Subset-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Subset-Simulation" title="Permalink"></a></h2><p>Subset simulation [<a href="../../references/#auEstimationSmallFailure2001">14</a>] is an advanced simulation technique for the estimation of small failure probabilities. This approach involves decomposing the problem into a sequence of conditional probabilities that are estimated using Markov Chain Monte Carlo.</p><p>We create the <a href="../../api/simulations/#UncertaintyQuantification.SubSetSimulation"><code>SubSetSimulation</code></a> object and compute the probability of failure using a standard Gaussian proposal PDF. The value for the target probability of failure at each intermediate level is set to <span>$0.1$</span> which is generally accepted as the optimal value.</p><pre><code class="language-julia hljs">subset = SubSetSimulation(1000, 0.1, 10, Normal())
pf_sus, std_sus, samples = probability_of_failure(y, g, x, subset)

println(&quot;Probability of failure: $pf_sus&quot;)
println(&quot;Coefficient of variation: $(std_sus/pf_sus)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 9.756600000000002e-6
Coefficient of variation: 0.3617787703556825</code></pre><p>Alternatively, instead of using the standard Subset simulation algorithm (which internally uses Markov Chain Monte Carlo), we can use <a href="../../api/simulations/#UncertaintyQuantification.SubSetInfinity"><code>SubSetInfinity</code></a> to compute the probability of failure, see [<a href="../../references/#auRareEventSimulation2016">15</a>]. Here we use a standard deviation of <span>$0.5$</span> to create the proposal samples for the next level.</p><pre><code class="language-julia hljs">subset = SubSetInfinity(1000, 0.1, 10, 0.5)
pf_sus, std_sus, samples = probability_of_failure(y, g, x, subset)

println(&quot;Probability of failure: $pf_sus&quot;)
println(&quot;Coefficient of variation: $(std_sus/pf_sus)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Probability of failure: 1.4600000000000004e-5
Coefficient of variation: 0.31969069307399456</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gettingstarted/">« Getting Started</a><a class="docs-footer-nextpage" href="../metamodels/">Metamodelling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 30 September 2024 13:56">Monday 30 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
