var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"manual/reliability/#Reliability-Analysis","page":"Reliability Analysis","title":"Reliability Analysis","text":"","category":"section"},{"location":"manual/reliability/#Subset-Simulation","page":"Reliability Analysis","title":"Subset Simulation","text":"","category":"section"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"Subset simulation (Siu-Kui Au, James L. Beck (2001)) is an advanced simulation technique for the estimation of small failure probabilities. Here we solve a simple problem where the response y depends on two independent random variables x_1 and x_2 following a standard normal distribution. The simple linear model is defined by","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"y(x_1x_2) = x_1 + x_2","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"with the failure domain","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"F = (x_1 x_2)  x_1 + x_2  9","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"The analytical probability of failure can be calculated as","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"pf = 1 - Phi(frac9sqrt(2)) approx 1 times 10^-10","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"This example is taken from Konstantin Zuev (2015).","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"In order to solve this, we start by creating the two random variables and group them in a vector inputs.","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"using UncertaintyQuantification, DataFrames # hide\nusing Random; Random.seed!(8128) # hide\nx1 = RandomVariable(Normal(), :x1)\nx2 = RandomVariable(Normal(), :x2)\ninputs = [x1, x2]","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"Next we define the model as","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"y = Model(df -> df.x1 + df.x2, :y)\nnothing # hide","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"where the first input is our function (which must accept a DataFrame) and the second the Symbol for the output variable.","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"To estimate a failure probability we need a performance which is negative if a failure occurs.","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"function g(df::DataFrame)\n    return 9 .- df.y\nend\nnothing # hide","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"Finally, we create the SubSetSimulation object and compute the probability of failure using a standard Gaussian proposal PDF. The value for the target probability of failure at each intermediate level is set to 01 which is generally accepted as the optimal value.","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"subset = SubSetSimulation(1000, 0.1, 10, Normal())\npf, cov, samples = probability_of_failure(y, g, inputs, subset)\n\nprintln(\"Probability of failure: $pf\")","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"Alternatively, instead of using the standard Subset simulation algorithm (which internally uses Markov Chain Monte Carlo), we can use SubSetInfinity to compute the probability of failure, see Siu-Kui Au, Edoardo Patelli (2016). Here we use a standard deviation of 05 to create the proposal samples for the next level.","category":"page"},{"location":"manual/reliability/","page":"Reliability Analysis","title":"Reliability Analysis","text":"subset = SubSetInfinity(1000, 0.1, 10, 0.5)\npf, cov, samples = probability_of_failure(y, g, inputs, subset)\n\nprintln(\"Probability of failure: $pf\")","category":"page"},{"location":"manual/uncertainty/#Uncertainty-Propagation","page":"Uncertainty Propagation","title":"Uncertainty Propagation","text":"","category":"section"},{"location":"manual/uncertainty/","page":"Uncertainty Propagation","title":"Uncertainty Propagation","text":"TODO","category":"page"},{"location":"manual/uncertainty/","page":"Uncertainty Propagation","title":"Uncertainty Propagation","text":"Defining random variables\nDefining correlations\nSimulation methods\nPlotting output","category":"page"},{"location":"api/randomvariable/#RandomVariable","page":"RandomVariable","title":"RandomVariable","text":"","category":"section"},{"location":"api/randomvariable/#Index","page":"RandomVariable","title":"Index","text":"","category":"section"},{"location":"api/randomvariable/","page":"RandomVariable","title":"RandomVariable","text":"Pages = [\"randomvariable.md\"]\nModule = [\"UncertaintyQuantification\"]","category":"page"},{"location":"api/randomvariable/#Type","page":"RandomVariable","title":"Type","text":"","category":"section"},{"location":"api/randomvariable/","page":"RandomVariable","title":"RandomVariable","text":"RandomVariable","category":"page"},{"location":"api/randomvariable/#UncertaintyQuantification.RandomVariable","page":"RandomVariable","title":"UncertaintyQuantification.RandomVariable","text":"RandomVariable(dist::UnivariateDistribution, name::Symbol)\n\nDefines a random variable, with a univariate distribution from Distributions.jl and a name.\n\nExamples\n\njulia> RandomVariable(Normal(), :x)\nRandomVariable(Normal{Float64}(μ=0.0, σ=1.0), :x)\n\njulia> RandomVariable(Exponential(1), :x)\nRandomVariable(Exponential{Float64}(θ=1.0), :x)\n\n\n\n\n\n","category":"type"},{"location":"api/randomvariable/#Functions","page":"RandomVariable","title":"Functions","text":"","category":"section"},{"location":"api/randomvariable/","page":"RandomVariable","title":"RandomVariable","text":"sample(rv::RandomVariable, n::Integer)","category":"page"},{"location":"api/randomvariable/#UncertaintyQuantification.sample-Tuple{RandomVariable, Integer}","page":"RandomVariable","title":"UncertaintyQuantification.sample","text":"sample(rv::RandomVariable, n::Integer)\n\nGenerates n samples from a random variable. Returns a DataFrame.\n\nExamples\n\nSee also: RandomVariable\n\n\n\n\n\n","category":"method"},{"location":"api/inputs/#Inputs","page":"Inputs","title":"Inputs","text":"","category":"section"},{"location":"api/inputs/","page":"Inputs","title":"Inputs","text":"General functions operating on a collection of inputs defined as subtypes of UQInput.","category":"page"},{"location":"api/inputs/#Index","page":"Inputs","title":"Index","text":"","category":"section"},{"location":"api/inputs/","page":"Inputs","title":"Inputs","text":"Pages = [\"inputs.md\"]\nModule = [\"UncertaintyQuantification\"]","category":"page"},{"location":"api/inputs/#Functions","page":"Inputs","title":"Functions","text":"","category":"section"},{"location":"api/inputs/","page":"Inputs","title":"Inputs","text":"sample(inputs::Array{<:UQInput}, n::Integer)","category":"page"},{"location":"api/inputs/#UncertaintyQuantification.sample-Tuple{Array{<:UQInput}, Integer}","page":"Inputs","title":"UncertaintyQuantification.sample","text":"sample(inputs::Array{<:UQInput}, n::Integer)\n\nGenerates n correlated samples from a collection of inputs. Returns a DataFrame\n\nSee also: RandomVariable, Parameter\n\n\n\n\n\n","category":"method"},{"location":"api/simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"api/simulations/","page":"Simulations","title":"Simulations","text":"Various Monte Carlo based simulations for a wide range of applications.","category":"page"},{"location":"api/simulations/#Index","page":"Simulations","title":"Index","text":"","category":"section"},{"location":"api/simulations/","page":"Simulations","title":"Simulations","text":"Pages = [\"simulations.md\"]\nModule = [\"UncertaintyQuantification\"]","category":"page"},{"location":"api/simulations/#Types","page":"Simulations","title":"Types","text":"","category":"section"},{"location":"api/simulations/","page":"Simulations","title":"Simulations","text":"SubSetSimulation\nSubSetInfinity","category":"page"},{"location":"api/simulations/#UncertaintyQuantification.SubSetSimulation","page":"Simulations","title":"UncertaintyQuantification.SubSetSimulation","text":"SubSetSimulation(n::Integer, target::Float64, levels::Integer, proposal::UnivariateDistribution)\n\nDefines the properties of a Subset simulation where n is the number of initial samples, target is the target probability of failure at each level, levels is the maximum number of levels and proposal is the proposal distribution for the markov chain monte carlo.\n\nExamples\n\njulia> SubSetSimulation(100, 0.1, 10, Uniform(-0.2, 0.2))\nSubSetSimulation(100, 0.1, 10, Uniform{Float64}(a=-0.2, b=0.2))\n\nReferences\n\nSiu-Kui Au, James L. Beck (2001)\n\n\n\n\n\n","category":"type"},{"location":"api/simulations/#UncertaintyQuantification.SubSetInfinity","page":"Simulations","title":"UncertaintyQuantification.SubSetInfinity","text":"SubSetInfinity(n::Integer, target::Float64, levels::Integer, s::Real)\n\nDefines the properties of a Subset-∞ simulation where n is the number of initial samples, target is the target probability of failure at each level, levels is the maximum number of levels and s is the standard deviation for the proposal samples.\n\nExamples\n\njulia> SubSetInfinity(100, 0.1, 10, 0.5)\nSubSetInfinity(100, 0.1, 10, 0.5)\n\nReferences\n\nSiu-Kui Au, Edoardo Patelli (2016)\n\nEdoardo Patelli, Siu Kui Au (2015)\n\n\n\n\n\n","category":"type"},{"location":"api/parameter/#Parameter","page":"Parameter","title":"Parameter","text":"","category":"section"},{"location":"api/parameter/#Index","page":"Parameter","title":"Index","text":"","category":"section"},{"location":"api/parameter/","page":"Parameter","title":"Parameter","text":"Pages = [\"parameter.md\"]\nModule = [\"UncertaintyQuantification\"]","category":"page"},{"location":"api/parameter/#Type","page":"Parameter","title":"Type","text":"","category":"section"},{"location":"api/parameter/","page":"Parameter","title":"Parameter","text":"Parameter","category":"page"},{"location":"api/parameter/#UncertaintyQuantification.Parameter","page":"Parameter","title":"UncertaintyQuantification.Parameter","text":"Parameter(value::Real, name::Symbol)\n\nDefines a parameter value (scalar), with an input value and a name.\n\nExamples\n\njulia> Parameter(3.14, :π)\nParameter(3.14, :π)\n\n\n\n\n\n","category":"type"},{"location":"manual/sensitivity/#Sensitivity-Analysis","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"","category":"section"},{"location":"manual/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"TODO","category":"page"},{"location":"manual/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Simulation methods\nDifferent indices","category":"page"},{"location":"api/polyharmonicspline/#PolyharmonicSpline","page":"PolyharmonicSpline","title":"PolyharmonicSpline","text":"","category":"section"},{"location":"api/polyharmonicspline/#Index","page":"PolyharmonicSpline","title":"Index","text":"","category":"section"},{"location":"api/polyharmonicspline/","page":"PolyharmonicSpline","title":"PolyharmonicSpline","text":"    Pages = [\"polyharmonicspline.md\"]\n    Module = [\"UncertaintyQuantification\"]","category":"page"},{"location":"api/polyharmonicspline/#Type","page":"PolyharmonicSpline","title":"Type","text":"","category":"section"},{"location":"api/polyharmonicspline/","page":"PolyharmonicSpline","title":"PolyharmonicSpline","text":"PolyharmonicSpline","category":"page"},{"location":"api/polyharmonicspline/#UncertaintyQuantification.PolyharmonicSpline","page":"PolyharmonicSpline","title":"UncertaintyQuantification.PolyharmonicSpline","text":"PolyharmonicSpline(data::DataFrame, k::Int64, output::Symbol)\n\nCreates a polyharmonic spline that is trained by given data.\n\n#Examples\n\njulia> data = DataFrame(x = 1:10, y = [1, -5, -10, -12, -8, -1, 5, 12, 23, 50]);\n\njulia> PolyharmonicSpline(data, 2, :y) |> DisplayAs.withcontext(:compact => true)\nPolyharmonicSpline([1.14733; -0.449609; … ; -5.33101; 3.88628;;], [-112.005; 6.84443;;], [1.0; 2.0; … ; 9.0; 10.0;;], 2, [:x], :y)\n\n\n\n\n\n","category":"type"},{"location":"api/polyharmonicspline/#Functions","page":"PolyharmonicSpline","title":"Functions","text":"","category":"section"},{"location":"api/polyharmonicspline/","page":"PolyharmonicSpline","title":"PolyharmonicSpline","text":"evaluate!(ps::PolyharmonicSpline, df::DataFrame)","category":"page"},{"location":"api/polyharmonicspline/#UncertaintyQuantification.evaluate!-Tuple{PolyharmonicSpline, DataFrame}","page":"PolyharmonicSpline","title":"UncertaintyQuantification.evaluate!","text":"evaluate!(ps::PolyharmonicSpline, df::DataFrame)\n\nEvaluate given data using a previously contructed PolyharmonicSpline metamodel.\n\n#Examples\n\njulia> data = DataFrame(x = 1:10, y = [1, -5, -10, -12, -8, -1, 5, 12, 23, 50]);\n\njulia> ps = PolyharmonicSpline(data, 2, :y);\n\njulia> df = DataFrame( x = [2.5, 7.5, 12, 30]);\n\njulia> evaluate!(ps, df);\n\njulia> df.y |> DisplayAs.withcontext(:compact => true)\n4-element Vector{Float64}:\n  -7.75427\n   8.29083\n  84.4685\n 260.437\n\n\n\n\n\n","category":"method"},{"location":"api/responsesurface/#ResponseSurface","page":"ResponseSurface","title":"ResponseSurface","text":"","category":"section"},{"location":"api/responsesurface/#Index","page":"ResponseSurface","title":"Index","text":"","category":"section"},{"location":"api/responsesurface/","page":"ResponseSurface","title":"ResponseSurface","text":"    Pages = [\"responcesurface.md\"]\n    Module = [\"UncertaintyQuantification\"]","category":"page"},{"location":"api/responsesurface/#Type","page":"ResponseSurface","title":"Type","text":"","category":"section"},{"location":"api/responsesurface/","page":"ResponseSurface","title":"ResponseSurface","text":"ResponseSurface","category":"page"},{"location":"api/responsesurface/#UncertaintyQuantification.ResponseSurface","page":"ResponseSurface","title":"UncertaintyQuantification.ResponseSurface","text":"ResponseSurface(data::DataFrame, dependendVarName::Symbol, deg::Int64, dim::Int64)\n\nCreates a response surface using polynomial least squares regression with given degree.\n\nExamples\n\njulia> data = DataFrame(x = 1:10, y = [1, 4, 10, 15, 24, 37, 50, 62, 80, 101]);\n\njulia> rs = ResponseSurface(data, :y, 2) |> DisplayAs.withcontext(:compact => true)\nResponseSurface([1.01894, -0.238636, 0.483333], :y, [:x], 2, DynamicPolynomials.Monomial{true}[x₁², x₁, 1])\n\n\n\n\n\n","category":"type"},{"location":"api/responsesurface/#Functions","page":"ResponseSurface","title":"Functions","text":"","category":"section"},{"location":"api/responsesurface/","page":"ResponseSurface","title":"ResponseSurface","text":"evaluate!(rs::ResponseSurface, data::DataFrame)","category":"page"},{"location":"api/responsesurface/#UncertaintyQuantification.evaluate!-Tuple{ResponseSurface, DataFrame}","page":"ResponseSurface","title":"UncertaintyQuantification.evaluate!","text":"evaluate!(rs::ResponseSurface, data::DataFrame)\n\nevaluating data by using a previously trained ResponseSurface.\n\nExamples\n\njulia> data = DataFrame(x = 1:10, y = [1, 4, 10, 15, 24, 37, 50, 62, 80, 101]);\n\njulia> rs = ResponseSurface(data, :y, 2);\n\njulia> df = DataFrame(x = [2.5, 11, 15]);\n\njulia> evaluate!(rs, df);\n\njulia> df.y |> DisplayAs.withcontext(:compact => true)\n3-element Vector{Float64}:\n   6.25511\n 121.15\n 226.165\n\n\n\n\n\n","category":"method"},{"location":"#UncertaintyQuantification.jl","page":"Home","title":"UncertaintyQuantification.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for uncertainty quantification. Current functionality includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation-based reliability analysis\nMonte Carlo simulation\nQuasi Monte Carlo simulation (Sobol, Halton)\nLine Sampling\nSubset Simulation\nSensitivity analysis\nGradients\nSobol indices\nMetamodeling\nPolyharmonic splines\nThird-party solvers\nConnect to any solver by injecting random samples into source files","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the latest release through the Julia package manager run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add UncertaintyQuantification\njulia> using UncertaintyQuantification","category":"page"},{"location":"","page":"Home","title":"Home","text":"or install the latest development version with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add UncertaintyQuantification#master\njulia> using UncertaintyQuantification","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jasper Behrensdorf, Institute for Risk and Reliability, Leibniz University Hannover\nAnder Gray, Institute for Risk and Uncertainty, University of Liverpool","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpenCossan: Matlab-based toolbox for uncertainty quantification and management","category":"page"}]
}
